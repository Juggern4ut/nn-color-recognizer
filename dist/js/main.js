/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst nn_1 = __webpack_require__(/*! ./nn */ \"./src/js/nn.js\");\r\nconst sessionsSpan = document.querySelector(\"#sessions\");\r\nconst errorLabel = document.querySelector(\"#error\");\r\nconst predictionDiv = document.querySelector(\"#prediction\");\r\nconst body = document.querySelector(\"body\");\r\nconst comp = document.querySelector(\"#compliment\");\r\nconst next = document.querySelector(\"#next\");\r\nconst train = document.querySelector(\"#train\");\r\nconst brain = new nn_1.NeuralNetwork(3, 5, 3);\r\nlet sessions = 0;\r\nlet predictValues = [0, 0, 0];\r\nlet testValues = [0, 0, 0];\r\n/**\r\n * Sets a random color for the testValues\r\n */\r\nconst pickRandomColor = () => {\r\n    testValues[0] = Math.random();\r\n    testValues[1] = Math.random();\r\n    testValues[2] = Math.random();\r\n};\r\n/**\r\n * Generates a new color and lets the neural network predict the complement.\r\n */\r\nconst nextColor = () => {\r\n    pickRandomColor();\r\n    predictValues = brain.predict(testValues);\r\n    const target = complementryRGBColor(testValues[0] * 255, testValues[1] * 255, testValues[2] * 255);\r\n    const err = calculateError(predictValues, target);\r\n    errorLabel.innerHTML = `${Math.floor((1 - err) * 100)}%`;\r\n    setBackgroundColor(body, testValues);\r\n    setBackgroundColor(comp, target);\r\n    setBackgroundColor(predictionDiv, predictValues);\r\n};\r\nnext.addEventListener(\"mouseup\", () => {\r\n    nextColor();\r\n});\r\ntrain.addEventListener(\"click\", (e) => {\r\n    for (let i = 0; i < 500; i++) {\r\n        pickRandomColor();\r\n        const t = complementryRGBColor(testValues[0] * 255, testValues[1] * 255, testValues[2] * 255);\r\n        brain.train(testValues, t);\r\n        sessions++;\r\n    }\r\n    sessionsSpan.innerHTML = sessions\r\n        .toString()\r\n        .replace(/\\B(?=(\\d{3})+(?!\\d))/g, \"'\");\r\n});\r\n/**\r\n * Calculates the error-margin between two arrays\r\n * @param a The first Array\r\n * @param b The second Array\r\n * @returns A number between 0 and 1\r\n */\r\nconst calculateError = (a, b) => {\r\n    const diff = [\r\n        a[0] * 255 - b[0] * 255,\r\n        a[1] * 255 - b[1] * 255,\r\n        a[2] * 255 - b[2] * 255,\r\n    ];\r\n    const distance = Math.sqrt(diff[0] ** 2 + diff[1] ** 2 + diff[2] ** 2);\r\n    const maxDistance = Math.sqrt(3 * 255 ** 2);\r\n    return distance / maxDistance;\r\n};\r\n/**\r\n * Calculates the complementry color of a given value\r\n * This function is only used for training the Neural-Network\r\n * @param r R value between 0 and 255\r\n * @param g G-Value between 0 and 255\r\n * @param b B-VAlue between 0 and 255\r\n * @returns An array containing 3 normalized numbers between 0 and 1 for r g and b\r\n */\r\nconst complementryRGBColor = (r, g, b) => {\r\n    if (Math.max(r, g, b) == Math.min(r, g, b)) {\r\n        return [255 - r, 255 - g, 255 - b];\r\n    }\r\n    else {\r\n        (r /= 255), (g /= 255), (b /= 255);\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        let h = 0;\r\n        let s;\r\n        let l = (max + min) / 2;\r\n        let d = max - min;\r\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        switch (max) {\r\n            case r:\r\n                h = (g - b) / d + (g < b ? 6 : 0);\r\n                break;\r\n            case g:\r\n                h = (b - r) / d + 2;\r\n                break;\r\n            case b:\r\n                h = (r - g) / d + 4;\r\n                break;\r\n        }\r\n        h = Math.round(h * 60 + 180) % 360;\r\n        h /= 360;\r\n        function hue2rgb(p, q, t) {\r\n            if (t < 0)\r\n                t += 1;\r\n            if (t > 1)\r\n                t -= 1;\r\n            if (t < 1 / 6)\r\n                return p + (q - p) * 6 * t;\r\n            if (t < 1 / 2)\r\n                return q;\r\n            if (t < 2 / 3)\r\n                return p + (q - p) * (2 / 3 - t) * 6;\r\n            return p;\r\n        }\r\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        var p = 2 * l - q;\r\n        r = hue2rgb(p, q, h + 1 / 3);\r\n        g = hue2rgb(p, q, h);\r\n        b = hue2rgb(p, q, h - 1 / 3);\r\n        return [r, g, b];\r\n    }\r\n};\r\n/**\r\n * Will set the backgroundColor of an Element to a given value\r\n * @param el The element to change the background\r\n * @param colors An array containing three numbers between 0 and 1\r\n */\r\nconst setBackgroundColor = (el, colors) => {\r\n    const r = colors[0] * 255;\r\n    const g = colors[1] * 255;\r\n    const b = colors[2] * 255;\r\n    el.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;\r\n};\r\nnextColor();\r\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack://wetyss-boiler/./src/js/main.js?");

/***/ }),

/***/ "./src/js/matrix.js":
/*!**************************!*\
  !*** ./src/js/matrix.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n// let m = new Matrix(3,2);\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nclass Matrix {\r\n    constructor(rows, cols) {\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n        this.data = Array(this.rows)\r\n            .fill(0)\r\n            .map(() => Array(this.cols).fill(0));\r\n    }\r\n    copy() {\r\n        let m = new Matrix(this.rows, this.cols);\r\n        for (let i = 0; i < this.rows; i++) {\r\n            for (let j = 0; j < this.cols; j++) {\r\n                m.data[i][j] = this.data[i][j];\r\n            }\r\n        }\r\n        return m;\r\n    }\r\n    static fromArray(arr) {\r\n        return new Matrix(arr.length, 1).map((e, i) => arr[i]);\r\n    }\r\n    static subtract(a, b) {\r\n        if (a.rows !== b.rows || a.cols !== b.cols) {\r\n            console.log(\"Columns and Rows of A must match Columns and Rows of B.\");\r\n            return;\r\n        }\r\n        // Return a new Matrix a-b\r\n        return new Matrix(a.rows, a.cols).map((_, i, j) => a.data[i][j] - b.data[i][j]);\r\n    }\r\n    toArray() {\r\n        let arr = [];\r\n        for (let i = 0; i < this.rows; i++) {\r\n            for (let j = 0; j < this.cols; j++) {\r\n                arr.push(this.data[i][j]);\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    randomize() {\r\n        return this.map((e) => Math.random() * 2 - 1);\r\n    }\r\n    add(n) {\r\n        if (n instanceof Matrix) {\r\n            if (this.rows !== n.rows || this.cols !== n.cols) {\r\n                console.log(\"Columns and Rows of A must match Columns and Rows of B.\");\r\n                return;\r\n            }\r\n            return this.map((e, i, j) => e + n.data[i][j]);\r\n        }\r\n        else {\r\n            return this.map((e) => e + n);\r\n        }\r\n    }\r\n    static transpose(matrix) {\r\n        return new Matrix(matrix.cols, matrix.rows).map((_, i, j) => matrix.data[j][i]);\r\n    }\r\n    static multiply(a, b) {\r\n        // Matrix product\r\n        if (a.cols !== b.rows) {\r\n            console.log(\"Columns of A must match rows of B.\");\r\n            return;\r\n        }\r\n        return new Matrix(a.rows, b.cols).map((e, i, j) => {\r\n            // Dot product of values in col\r\n            let sum = 0;\r\n            for (let k = 0; k < a.cols; k++) {\r\n                sum += a.data[i][k] * b.data[k][j];\r\n            }\r\n            return sum;\r\n        });\r\n    }\r\n    multiply(n) {\r\n        if (n instanceof Matrix) {\r\n            if (this.rows !== n.rows || this.cols !== n.cols) {\r\n                console.log(\"Columns and Rows of A must match Columns and Rows of B.\");\r\n                return;\r\n            }\r\n            // hadamard product\r\n            return this.map((e, i, j) => e * n.data[i][j]);\r\n        }\r\n        else {\r\n            // Scalar product\r\n            return this.map((e) => e * n);\r\n        }\r\n    }\r\n    map(func) {\r\n        // Apply a function to every element of matrix\r\n        for (let i = 0; i < this.rows; i++) {\r\n            for (let j = 0; j < this.cols; j++) {\r\n                let val = this.data[i][j];\r\n                this.data[i][j] = func(val, i, j);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    static map(matrix, func) {\r\n        // Apply a function to every element of matrix\r\n        return new Matrix(matrix.rows, matrix.cols).map((e, i, j) => func(matrix.data[i][j], i, j));\r\n    }\r\n    print() {\r\n        console.table(this.data);\r\n        return this;\r\n    }\r\n    serialize() {\r\n        return JSON.stringify(this);\r\n    }\r\n    static deserialize(data) {\r\n        if (typeof data == \"string\") {\r\n            data = JSON.parse(data);\r\n        }\r\n        let matrix = new Matrix(data.rows, data.cols);\r\n        matrix.data = data.data;\r\n        return matrix;\r\n    }\r\n}\r\nexports[\"default\"] = Matrix;\r\n//# sourceMappingURL=matrix.js.map\n\n//# sourceURL=webpack://wetyss-boiler/./src/js/matrix.js?");

/***/ }),

/***/ "./src/js/nn.js":
/*!**********************!*\
  !*** ./src/js/nn.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\n// Other techniques for learning\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.NeuralNetwork = exports.ActivationFunction = void 0;\r\nconst matrix_1 = __importDefault(__webpack_require__(/*! ./matrix */ \"./src/js/matrix.js\"));\r\nclass ActivationFunction {\r\n    constructor(func, dfunc) {\r\n        this.func = func;\r\n        this.dfunc = dfunc;\r\n    }\r\n}\r\nexports.ActivationFunction = ActivationFunction;\r\nlet sigmoid = new ActivationFunction(x => 1 / (1 + Math.exp(-x)), y => y * (1 - y));\r\nlet tanh = new ActivationFunction(x => Math.tanh(x), y => 1 - (y * y));\r\nclass NeuralNetwork {\r\n    /*\r\n    * if first argument is a NeuralNetwork the constructor clones it\r\n    * USAGE: cloned_nn = new NeuralNetwork(to_clone_nn);\r\n    */\r\n    constructor(in_nodes, hid_nodes, out_nodes) {\r\n        if (in_nodes instanceof NeuralNetwork) {\r\n            let a = in_nodes;\r\n            this.input_nodes = a.input_nodes;\r\n            this.hidden_nodes = a.hidden_nodes;\r\n            this.output_nodes = a.output_nodes;\r\n            this.weights_ih = a.weights_ih.copy();\r\n            this.weights_ho = a.weights_ho.copy();\r\n            this.bias_h = a.bias_h.copy();\r\n            this.bias_o = a.bias_o.copy();\r\n        }\r\n        else {\r\n            this.input_nodes = in_nodes;\r\n            this.hidden_nodes = hid_nodes;\r\n            this.output_nodes = out_nodes;\r\n            this.weights_ih = new matrix_1.default(this.hidden_nodes, this.input_nodes);\r\n            this.weights_ho = new matrix_1.default(this.output_nodes, this.hidden_nodes);\r\n            this.weights_ih.randomize();\r\n            this.weights_ho.randomize();\r\n            this.bias_h = new matrix_1.default(this.hidden_nodes, 1);\r\n            this.bias_o = new matrix_1.default(this.output_nodes, 1);\r\n            this.bias_h.randomize();\r\n            this.bias_o.randomize();\r\n        }\r\n        // TODO: copy these as well\r\n        this.setLearningRate();\r\n        this.setActivationFunction();\r\n    }\r\n    predict(input_array) {\r\n        // Generating the Hidden Outputs\r\n        let inputs = matrix_1.default.fromArray(input_array);\r\n        let hidden = matrix_1.default.multiply(this.weights_ih, inputs);\r\n        hidden.add(this.bias_h);\r\n        // activation function!\r\n        hidden.map(this.activation_function.func);\r\n        // Generating the output's output!\r\n        let output = matrix_1.default.multiply(this.weights_ho, hidden);\r\n        output.add(this.bias_o);\r\n        output.map(this.activation_function.func);\r\n        // Sending back to the caller!\r\n        return output.toArray();\r\n    }\r\n    setLearningRate(learning_rate = 0.1) {\r\n        this.learning_rate = learning_rate;\r\n    }\r\n    setActivationFunction(func = sigmoid) {\r\n        this.activation_function = func;\r\n    }\r\n    train(input_array, target_array) {\r\n        // Generating the Hidden Outputs\r\n        let inputs = matrix_1.default.fromArray(input_array);\r\n        let hidden = matrix_1.default.multiply(this.weights_ih, inputs);\r\n        hidden.add(this.bias_h);\r\n        // activation function!\r\n        hidden.map(this.activation_function.func);\r\n        // Generating the output's output!\r\n        let outputs = matrix_1.default.multiply(this.weights_ho, hidden);\r\n        outputs.add(this.bias_o);\r\n        outputs.map(this.activation_function.func);\r\n        // Convert array to matrix object\r\n        let targets = matrix_1.default.fromArray(target_array);\r\n        // Calculate the error\r\n        // ERROR = TARGETS - OUTPUTS\r\n        let output_errors = matrix_1.default.subtract(targets, outputs);\r\n        // let gradient = outputs * (1 - outputs);\r\n        // Calculate gradient\r\n        let gradients = matrix_1.default.map(outputs, this.activation_function.dfunc);\r\n        gradients.multiply(output_errors);\r\n        gradients.multiply(this.learning_rate);\r\n        // Calculate deltas\r\n        let hidden_T = matrix_1.default.transpose(hidden);\r\n        let weight_ho_deltas = matrix_1.default.multiply(gradients, hidden_T);\r\n        // Adjust the weights by deltas\r\n        this.weights_ho.add(weight_ho_deltas);\r\n        // Adjust the bias by its deltas (which is just the gradients)\r\n        this.bias_o.add(gradients);\r\n        // Calculate the hidden layer errors\r\n        let who_t = matrix_1.default.transpose(this.weights_ho);\r\n        let hidden_errors = matrix_1.default.multiply(who_t, output_errors);\r\n        // Calculate hidden gradient\r\n        let hidden_gradient = matrix_1.default.map(hidden, this.activation_function.dfunc);\r\n        hidden_gradient.multiply(hidden_errors);\r\n        hidden_gradient.multiply(this.learning_rate);\r\n        // Calcuate input->hidden deltas\r\n        let inputs_T = matrix_1.default.transpose(inputs);\r\n        let weight_ih_deltas = matrix_1.default.multiply(hidden_gradient, inputs_T);\r\n        this.weights_ih.add(weight_ih_deltas);\r\n        // Adjust the bias by its deltas (which is just the gradients)\r\n        this.bias_h.add(hidden_gradient);\r\n        // outputs.print();\r\n        // targets.print();\r\n        // error.print();\r\n    }\r\n    serialize() {\r\n        return JSON.stringify(this);\r\n    }\r\n    static deserialize(data) {\r\n        if (typeof data == 'string') {\r\n            data = JSON.parse(data);\r\n        }\r\n        let nn = new NeuralNetwork(data.input_nodes, data.hidden_nodes, data.output_nodes);\r\n        nn.weights_ih = matrix_1.default.deserialize(data.weights_ih);\r\n        nn.weights_ho = matrix_1.default.deserialize(data.weights_ho);\r\n        nn.bias_h = matrix_1.default.deserialize(data.bias_h);\r\n        nn.bias_o = matrix_1.default.deserialize(data.bias_o);\r\n        nn.learning_rate = data.learning_rate;\r\n        return nn;\r\n    }\r\n    // Adding function for neuro-evolution\r\n    copy() {\r\n        return new NeuralNetwork(this);\r\n    }\r\n    // Accept an arbitrary function for mutation\r\n    mutate(func) {\r\n        this.weights_ih.map(func);\r\n        this.weights_ho.map(func);\r\n        this.bias_h.map(func);\r\n        this.bias_o.map(func);\r\n    }\r\n}\r\nexports.NeuralNetwork = NeuralNetwork;\r\n//# sourceMappingURL=nn.js.map\n\n//# sourceURL=webpack://wetyss-boiler/./src/js/nn.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/main.js");
/******/ 	
/******/ })()
;